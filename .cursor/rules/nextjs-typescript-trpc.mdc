---
description: Rules for Next.js 15 + TypeScript + tRPC + Prisma + Zod development
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# Next.js 15 + TypeScript + tRPC + Prisma + Zod Project Rules

## TypeScript Guidelines

### Type Safety

- Strict mode is enabled (`strict: true`, `noUncheckedIndexedAccess: true`)
- **AVOID `any` type** - use `unknown` if type is truly unknown, then narrow it down
- **MINIMIZE `as` type assertions** - rely on type inference and proper typing
- Only use type assertions when absolutely necessary (e.g., DOM manipulation, third-party libraries)
- Use `satisfies` operator instead of `as` when you want both type checking and inference
- Prefer `type` over `interface` for consistency, unless extending is specifically needed

### Type Inference

- Let TypeScript infer return types when obvious from implementation
- Explicitly type complex return types, public APIs, and exported functions
- Use `typeof` and `keyof` for deriving types from values
- Leverage tRPC's `RouterInputs` and `RouterOutputs` for type inference:

  ```typescript
  import type { RouterInputs, RouterOutputs } from "~/trpc/react";

  type HelloInput = RouterInputs["post"]["hello"];
  type HelloOutput = RouterOutputs["post"]["hello"];
  ```

### Imports and Aliases

- Use `~/*` path alias for all internal imports (maps to `./src/*`)
- Group imports: external packages → internal modules → types → styles
- Use `type` imports for type-only imports: `import type { User } from "~/types"`

## Next.js 15 Patterns

### App Router (App Directory)

- Use App Router (`src/app/`) for all routes
- File conventions:
  - `page.tsx` - route pages
  - `layout.tsx` - shared layouts
  - `loading.tsx` - loading states
  - `error.tsx` - error boundaries
  - `route.ts` - API routes
- Use React Server Components (RSC) by default
- Add `"use client"` directive only when necessary (hooks, browser APIs, interactivity)

### Server vs Client Components

- **Server Components (default):**
  - Data fetching with tRPC server caller
  - Direct database access via Prisma (in API routes/server actions)
  - Access to server-only resources
  - No hooks, no browser APIs, no event handlers
- **Client Components (`"use client"`):**
  - Interactive UI with state/effects
  - tRPC hooks (`api.post.hello.useQuery()`)
  - Browser APIs (localStorage, etc.)
  - Event handlers

### Data Fetching

- Server Components: Use tRPC server caller (`api.post.hello()`)
- Client Components: Use tRPC React hooks (`api.post.hello.useQuery()`)
- Prefer server-side data fetching when possible for better performance

## tRPC Best Practices

### Router Structure

- Define routers in `src/server/api/routers/`
- Group related procedures into routers (e.g., `postRouter`, `userRouter`)
- Combine routers in `src/server/api/root.ts`
- Pattern:

  ```typescript
  import { z } from "zod";
  import { createTRPCRouter, publicProcedure } from "~/server/api/trpc";

  export const exampleRouter = createTRPCRouter({
    getName: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input, ctx }) => {
        return ctx.db.example.findUnique({
          where: { id: input.id },
        });
      }),
  });
  ```

### Procedure Types

- `.query()` - for GET-like operations (data fetching)
- `.mutation()` - for POST/PUT/DELETE-like operations (data modification)
- Always use `.input()` with Zod schema for validation

### Context Usage

- Access database via `ctx.db` (Prisma client)
- Add user session, auth, etc. to context in `createTRPCContext` (trpc.ts)
- Don't import db directly in routers; use context

### Client Usage

- Import tRPC client: `import { api } from "~/trpc/react";`
- Queries: `const { data, isLoading } = api.post.getLatest.useQuery();`
- Mutations: `const mutation = api.post.create.useMutation();`
- Use TanStack Query options for advanced patterns (refetch, caching, etc.)

### Type Inference

- Export and use `RouterInputs` and `RouterOutputs` types
- Avoid redefining types that tRPC already infers
- Let procedure return types be inferred from implementation

## Zod Validation

### Input Validation

- **ALWAYS** validate inputs with Zod schemas in tRPC procedures
- Define schemas inline for simple cases
- Extract complex schemas into separate files/constants for reuse
- Use Zod's built-in validators:
  ```typescript
  z.string().min(1).max(100)
  z.string().email()
  z.string().uuid()
  z.number().int().positive()
  z.array(z.string()).nonempty()
  z.object({ ... }).strict() // no extra keys
  ```

### Schema Patterns

- Reuse schemas for consistency: `const createPostInput = z.object({ ... })`
- Use `.omit()`, `.pick()`, `.partial()` for schema variations
- Use `.extend()` to build on existing schemas
- Use `.refine()` for custom validation logic
- Type inference: `type CreatePostInput = z.infer<typeof createPostInput>`

### Integration with Prisma

- Don't duplicate Prisma schema in Zod - use Zod for input validation only
- Zod handles input, Prisma handles database schema and types
- Let tRPC return Prisma types directly (don't re-validate outputs)

## Prisma ORM

### Schema Design

- Define models in `prisma/schema.prisma`
- Use appropriate field types and constraints
- Add indexes for frequently queried fields
- Use relations (`@relation`) properly

### Usage Patterns

- Access Prisma client via context: `ctx.db`
- Use type-safe query methods: `findUnique`, `findFirst`, `findMany`, `create`, `update`, `delete`
- Leverage `select` and `include` for optimized queries
- Use transactions for atomic operations:
  ```typescript
  await ctx.db.$transaction([
    ctx.db.user.create({ ... }),
    ctx.db.post.create({ ... }),
  ]);
  ```

### Type Safety

- Prisma generates TypeScript types automatically
- Use Prisma types directly: `import type { Post } from "@prisma/client"`

## Error Handling

### tRPC Errors

- Use `TRPCError` for throwing errors:

  ```typescript
  import { TRPCError } from "@trpc/server";

  throw new TRPCError({
    code: "NOT_FOUND",
    message: "Post not found",
  });
  ```

- Common error codes: `BAD_REQUEST`, `UNAUTHORIZED`, `FORBIDDEN`, `NOT_FOUND`, `INTERNAL_SERVER_ERROR`

### Zod Errors

- Zod validation errors are automatically formatted by tRPC
- Access on client via error.data.zodError
- Don't catch Zod errors - let tRPC handle them

### Client Error Handling

- Handle errors in TanStack Query callbacks
- Use `onError` in mutations
- Display user-friendly error messages

## Async/Await Patterns

- Always use `async/await` for asynchronous operations
- Don't mix promises and async/await unnecessarily
- Handle errors with try-catch in server code
- In tRPC procedures, errors are automatically caught and formatted

## React Patterns

### Components

- Functional components only
- Use proper types for props, no `any`
- Destructure props in function signature

### Hooks

- Follow React hooks rules (top level, not in conditions)
- Custom hooks start with `use` prefix
- Type hook parameters and return values properly

### Server/Client Boundary

- Mark client components explicitly with `"use client"`
- Server components can import and render client components
- Client components cannot import server components
- Pass serializable props across boundary (no functions, no class instances)

## Code Organization

### Directory Structure

- `/src/app` - Next.js App Router pages and layouts
- `/src/app/api` - API routes (including tRPC)
- `/src/server` - Server-only code (tRPC routers, db, etc.)
- `/src/trpc` - tRPC client setup and React hooks
- `/prisma` - Database schema and migrations

### Imports

- Use absolute imports with `~/` prefix
- Keep imports organized and remove unused imports
- Don't import from barrel exports if it causes circular dependencies

## Performance

### Optimization

- Use React Server Components for static content
- Minimize client bundle size (use `"use client"` sparingly)
- Use tRPC batching (already configured with `httpBatchStreamLink`)
- Optimize Prisma queries with `select` to fetch only needed fields
- Use proper indexes in Prisma schema

## Testing Considerations

- Write testable code (pure functions, dependency injection)
- Mock Prisma client in tests
- Mock tRPC context in tests
- Use type-safe mocks

## Environment Variables

- Define environment variables in `.env` (and `.env.example`)
- Validate env vars with `@t3-oss/env-nextjs` (already configured in `src/env.js`)
- Access validated env vars from `~/env.js`
- Never commit `.env` file

## Common Pitfalls to Avoid

1. **Don't use `any`** - it defeats TypeScript's purpose
2. **Don't bypass type safety with excessive `as` casting**
3. **Don't forget input validation** - always use Zod in tRPC procedures
4. **Don't use `"use client"` unnecessarily** - prefer Server Components
5. **Don't import server code in client components** - respect the boundary
6. **Don't access database directly in client code** - use tRPC procedures
7. **Don't forget to handle loading and error states** in client components
8. **Don't expose sensitive data** - validate and sanitize all outputs
9. **Don't ignore TypeScript errors** - fix them, don't suppress them
10. **Don't duplicate types** - use inference from Zod, Prisma, and tRPC

## SuperJSON Transformer

- Already configured in tRPC setup
- Allows passing Date, Map, Set, undefined across client/server boundary
- No need to manually serialize/deserialize these types
- Be aware of what gets serialized (no functions, no class instances)

## Package Manager

- Use `pnpm` as specified in package.json
- Commands: `pnpm install`, `pnpm dev`, `pnpm build`
- Don't use `npm` or `yarn` in this project
